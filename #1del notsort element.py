#!/usr/bin/python
'''Из некоторого массива необходимо удалить все неотсортированные элементы'''
'''
По заданию из некоторого массива необходимо удалить все неотсортированные элементы. Неотсортированные элементы массива - элементы которые меньше следующего,
в нашем случае с массивом [6, 8, 2, 11, 4, 9, 20, 55] это элементы 8 и 2. Отсортированные когда на протяжении массива сохраняется сортировка
его элементов, т.е следующий элемент больше предыдущего. Весь массив хранитьсяя в файле #1delete notsort element.txt считываем его и проходим
по всему массиву сохраняяя его в mas_elementary.
Инициализируем две переменные для итерации по масссиву element_iterable и t. element_iterable нужен для доступа к элементам массива mas_elementary,
t нужен для итерации по массиву. Далее проходим поочередно по всем элементам массива, для сортировки был выбрана идея реализация алгоритма сортировки
простыми обменами или сортировка пузырьком, т.к алгоритм достаточно простой и массив mas_elementary не является сильно большим.
Алгоритм состоит из повторяющихся проходов по сортируемому массиву. За каждый проход элементы последовательно сравниваются попарно и,
если порядок в паре неверный, выполняется обмен элементов - в нашем случае необходимо не отсортировать все элементы а удалить неупорядо
ченные, поэтому в даном примере если поряядок неверный (8-2, 11-4, 11-9) элементы не меняются местами, а удаляются.
Проходы по массиву повторяются N-1 (N-1  прогоняяется сам алгоритмм которые проходит по массиву) раз или до тех пор, пока на очередном проходе
не окажется, что обмены больше не нужны, что означает — массив отсортирован. В данном случае это лишнее т.к часть элементов уже отсортированно
внутрри массива, а необхолимо удалить лиш те которые не соответствуют сортироовки.
При каждом проходе алгоритма по внутреннему циклу, очередной наибольший элемент массива ставится на своё место в конце массива рядом с предыдущим «наибольшим элементом»,
а наименьший элемент перемещается на одну позицию к началу массива («всплывает» до нужной позиции, как пузырёк в воде. Отсюда и название алгоритма).
В конце программы происходит проверка на исключение выхода за границы массива, Это происходит из за того что при достижениии последнего элемента
изначального массива, мы пытаемся сравнить его со следующим элементом, в итоге ловим искобчение. На последнем этапе сравнивам последний элемент
масива (на котором поймали исключение) с "последним элементом результирующего массива" и взависимости от резльтата добавляем его в результирующий
массив. Выводим результируюющий массив.
'''
#mas_elementary = [6, 8, 2, 11, 4, 9, 20, 55]
with open('#1delete notsort element.txt', 'r') as f:    # считывем массив из файла
    for mas in f:
        mas = mas.strip().split(' ')
        #print(mas)
mas_elementary = [int(t) for t in mas]                  # Считываем массив и переводим элементы в числа
print('Массив Изначальных элементов:', mas_elementary)
result_mas = []
element_iterable, t = 0, len(mas_elementary)-1          # элементы для итерации
while t > 0:                                            # t -  прохождения по циклу, по кол-ву элементов в массиве
    #print(t)
    try:
        if mas_elementary[element_iterable] < mas_elementary[element_iterable+1]:   #68,811,1120,2055, элемент меньше следующего за ним
            if mas_elementary[element_iterable] not in result_mas:                  # проверяем нет ли в результирующем массиве данного эолемента
                result_mas.append(mas_elementary[element_iterable])
            element_iterable+=1                                                     # Увеичиваем для доступа к следующему элементу
        elif mas_elementary[element_iterable] > mas_elementary[element_iterable+1]: #82-2иск, 114-4иск,119-9иск
            if mas_elementary[element_iterable] not in result_mas:                  # если в результирующем масиве еще нет данного элемента и он больше следующего за ним
                result_mas.append(mas_elementary[element_iterable])
            mas_elementary.pop(element_iterable+1)                                  # удаляем меньший элемент
            continue
        t-=1
    except IndexError:
        print("Достигнут последний элемент массива:")
        print("Массив mas_elementary преобразован в", mas_elementary)
        if mas_elementary[-1] > result_mas[-1]:                 # последний элемент массива больше последнего элемента результирующего массива, упорядоченность сохраняется
            result_mas.append(mas_elementary[-1])
            print("Результирующий массив", result_mas)
        break


